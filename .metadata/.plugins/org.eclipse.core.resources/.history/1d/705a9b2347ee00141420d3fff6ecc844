package hr.fer.zemris.linearna;

import java.util.function.DoubleBinaryOperator;
import java.util.stream.DoubleStream;

public abstract class AbstractVector implements IVector {

	@Override
	public IVector copyPart(int n) {
		IVector copied = newInstance(n);
		for (int index = 0, length = Math.min(getDimension(), n); index < length; index++) {
			copied.set(index, this.get(index));
		}
		return copied;
	}

	@Override
	public IVector add(IVector other) throws IncompatibleOperandException {
		return calc(other, (d1, d2) -> d1 + d2);
	}

	@Override
	public IVector nAdd(IVector other) throws IncompatibleOperandException {
		return this.copy().add(other);
	}

	@Override
	public IVector sub(IVector other) throws IncompatibleOperandException {
		return calc(other, (d1, d2) -> d1 - d2);
	}

	@Override
	public IVector nSub(IVector other) throws IncompatibleOperandException {
		return this.copy().sub(other);
	}

	@Override
	public IVector scalarMultiply(double byValue) {
		return calc(this, (d1, d2) -> d1 * byValue);
	}

	@Override
	public IVector nScalarMultiply(double byValue) {
		return this.copy().scalarMultiply(byValue);
	}

	@Override
	public double norm() {
		/*double result = 0;
		for (double dimension : toArray()) {
			result += dimension * dimension;
		}*/
		return Math.sqrt(DoubleStream.of(toArray()).reduce((r,e) -> e*e + r).getAsDouble());
		//return Math.sqrt(result);
	}

	@Override
	public IVector normalize() {
		return scalarMultiply(1. / norm());
	}

	@Override
	public IVector nNormalize() {
		return copy().normalize();
	}

	@Override
	public double cosine(IVector other) throws IncompatibleOperandException {
		return scalarProduct(other) / (this.norm() * other.norm());
	}

	@Override
	public double scalarProduct(IVector other)
			throws IncompatibleOperandException {
		// first multiply each dimension of one vector with the one other vector
		// and then sum them all
		IVector dimsMultiplied = ((AbstractVector) copy()).calc(other,
				(d1, d2) -> d1 * d2);

		double result = DoubleStream.of(dimsMultiplied.toArray()).sum();

		return result;
	}

	@Override
	public IVector nVectorProduct(IVector other)
			throws IncompatibleOperandException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public IVector nFromHomogeneus() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public IMatrix toRowMatrix(boolean liveView) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public IMatrix toColumnMatrix(boolean liveView) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public double[] toArray() {
		int length = getDimension();
		double[] array = new double[length];

		for (int i = 0; i < length; i++) {
			array[i] = get(i);
		}

		return array;
	}

	private IVector calc(IVector other, IDoubleOperator op)
			throws IncompatibleOperandException {
		
		if (this.getDimension() != other.getDimension()) {
			throw new IncompatibleOperandException();
		}
		for (int i = 0, length = getDimension(); i < length; i++) {
			this.set(i, op.calc(this.get(i), other.get(i)));
		}

		return this;
	}

}
