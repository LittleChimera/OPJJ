package hr.fer.zemris.java.fractals.complex;

import java.util.Arrays;
import java.util.Collections;



public final class ComplexRootedPolynomial {
	
	private Complex[] roots;

	// ...
	// constructor
	public ComplexRootedPolynomial(Complex... roots) {
		if (roots.length == 0) {
			throw new IllegalArgumentException();
		}
		this.roots = roots;
	}

	// computes polynomial value at given point z
	public Complex apply(Complex z) {
		Complex result = new Complex(1, 0);
		for (Complex complex : roots) {
			result = result.multiply(z.sub(complex));
		}
		
		return result;
	}

	// converts this representation to ComplexPolynomial type
	public ComplexPolynomial toComplexPolynom() {
		ComplexPolynomial sol = new ComplexPolynomial(Complex.ONE);
		Complex[] factors = new Complex[2];
		factors[0] = roots[0].negate();
		factors[1] = new Complex(1, 0);
		
		for (int i = 1; i < roots.length; i++) {
			Complex[] factorsMul = new Complex[factors.length + 1];
			System.arraycopy(factors, 0, factorsMul, 1, factors.length);
			factorsMul[0] = Complex.ZERO;
			
			for (int j = 0; j < factors.length; j++) {
				factorsMul[j] = factorsMul[j].add(factors[j].multiply(roots[i].negate()));
			}
			factors = factorsMul;
		}
		Collections.reverse(Arrays.asList(factors));
		System.out.println("toPolynom	");
		for (Complex complex : factors) {
			System.out.print(complex + " ");
		}
		return new ComplexPolynomial(factors);
	}

	@Override
	public String toString() {
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.append("f(z) = ");
		for (Complex complex : roots) {
			stringBuilder.append(String.format("(z %s)", complex.toString()));
		}
		
		return stringBuilder.toString();
	}

	// finds index of closest root for given complex number z that is within
	// treshold
	// if there is no such root, returns -1
	public int indexOfClosestRootFor(Complex z, double treshold) {
		double closestTreshold = treshold;
		int index = -1;
		for (int i = 0; i < roots.length; i++) {
			double currentTreshold = roots[i].sub(z).module();
			if(currentTreshold < closestTreshold) {
				closestTreshold = currentTreshold;
				index = i;
			}
		}
		
		return index + 1;
	}

}
