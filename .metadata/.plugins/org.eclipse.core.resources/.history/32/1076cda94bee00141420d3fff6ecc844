package hr.fer.zemris.linearna;

import java.util.function.DoubleBinaryOperator;

public abstract class AbstractMatrix implements IMatrix {

	@Override
	public IMatrix nTranspose(boolean liveView) {
		IMatrix transpose = new MatrixTransposeView(this);
		
		return (liveView)?transpose:transpose.copy();
	}

	@Override
	public IMatrix add(IMatrix other) {
		return calc(other, (d1, d2) -> d1 + d2);
	}

	@Override
	public IMatrix nAdd(IMatrix other) {
		return copy().add(other);
	}

	@Override
	public IMatrix sub(IMatrix other) {
		return calc(other, (d1, d2) -> d1 - d2);
	}

	@Override
	public IMatrix nSub(IMatrix other) {
		return copy().sub(other);
	}

	@Override
	public IMatrix nMultiply(IMatrix other) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public double determinant() throws IncompatibleOperandException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public IMatrix subMatrix(int row, int col, boolean liveView) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public IMatrix nInvert() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public IVector toVector(boolean liveView) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public IMatrix nScalarMultiply(double value) {
		return copy().scalarMultiply(value);
	}

	@Override
	public IMatrix scalarMultiply(double value) {
		return calc(this, (d1, d2) -> d1*value);
	}

	@Override
	public IMatrix makeIdentity() {
		//set all too zero and then fill diagonally with 1's
		sub(this);
		for (int i = 0, diagonal = Math.min(getColsCount(), getRowsCount()); i < diagonal; i++) {
			set(i, i, 1);
		}
	}
	
	private IMatrix calc(IMatrix other, DoubleBinaryOperator op) throws IncompatibleOperandException {
		if(other.getColsCount() != getColsCount() || other.getRowsCount() != getRowsCount()) {
			throw new IncompatibleOperandException();
		}
		
		for (int i = 0, rows = getRowsCount(); i < rows; i++) {
			for (int j = 0, cols = getColsCount(); j < cols; j++) {
				set(j, j, op.applyAsDouble(this.get(i, j), other.get(i, j)));
			}
		}
		
		return this;
	}

}
