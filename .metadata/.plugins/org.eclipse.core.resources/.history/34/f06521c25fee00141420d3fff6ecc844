package hr.fer.zemris.linearna;

import java.util.function.DoubleBinaryOperator;
import java.util.stream.DoubleStream;

public abstract class AbstractMatrix implements IMatrix {

	@Override
	public IMatrix nTranspose(boolean liveView) {
		IMatrix transpose = new MatrixTransposeView(this);

		return (liveView) ? transpose : transpose.copy();
	}

	@Override
	public IMatrix add(IMatrix other) {
		DoubleStream.of(new double[]{1, 2, 3}).sum();
		return calc(other, (d1, d2) -> d1 + d2);
	}

	@Override
	public IMatrix nAdd(IMatrix other) {
		return copy().add(other);
	}

	@Override
	public IMatrix sub(IMatrix other) {
		return calc(other, (d1, d2) -> d1 - d2);
	}

	@Override
	public IMatrix nSub(IMatrix other) {
		return copy().sub(other);
	}

	@Override
	public IMatrix nMultiply(IMatrix other) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public double determinant() throws IncompatibleOperandException {
		if (getRowsCount() != getColsCount()) {
			throw new IncompatibleOperandException();
		}
		if (getRowsCount() == 1) {
			return get(0, 0);
		}
		
		int result = 0;
		for (int i = 0, cols = getColsCount(); i < cols; i++) {
			result += subMatrix(0, i, true).determinant();
		}
		
		return result;
	}

	@Override
	public IMatrix subMatrix(int row, int col, boolean liveView) {
		IMatrix subMatrix = new MatrixSubMatrixView(this, row, col);
		return liveView?subMatrix:subMatrix.copy();
	}

	@Override
	public IMatrix nInvert() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public IVector toVector(boolean liveView) {
		if (getColsCount() != 1 && getRowsCount() != 1) {
			throw new IncompatibleOperandException();
		}
		//TODO
		return null;
		
	}

	@Override
	public IMatrix nScalarMultiply(double value) {
		return copy().scalarMultiply(value);
	}

	@Override
	public IMatrix scalarMultiply(double value) {
		return calc(this, (d1, d2) -> d1 * value);
	}

	@Override
	public IMatrix makeIdentity() {
		// set all too zero and then fill diagonally with 1's
		sub(this);
		for (int i = 0, diagonal = Math.min(getColsCount(), getRowsCount()); i < diagonal; i++) {
			set(i, i, 1);
		}
		return this;
	}

	private IMatrix calc(IMatrix other, DoubleBinaryOperator op)
			throws IncompatibleOperandException {
		if (other.getColsCount() != getColsCount()
				|| other.getRowsCount() != getRowsCount()) {
			throw new IncompatibleOperandException();
		}

		for (int i = 0, rows = getRowsCount(); i < rows; i++) {
			for (int j = 0, cols = getColsCount(); j < cols; j++) {
				set(j, j, op.applyAsDouble(this.get(i, j), other.get(i, j)));
			}
		}

		return this;
	}

}
