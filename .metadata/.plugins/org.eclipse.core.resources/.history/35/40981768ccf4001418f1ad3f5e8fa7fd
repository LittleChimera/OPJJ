package hr.fer.zemris.java.raytracer.model;

import java.util.LinkedList;

public class Sphere extends GraphicalObject {

	private Point3D center;
	private double radius;
	private double kdr;
	private double kdg;
	private double kdb;
	private double krr;
	private double krg;
	private double krb;
	private double krn;

	public Sphere(Point3D center, double radius, double kdr, double kdg,
			double kdb, double krr, double krg, double krb, double krn) {
		super();
		this.center = center;
		this.radius = radius;
		this.kdr = kdr;
		this.kdg = kdg;
		this.kdb = kdb;
		this.krr = krr;
		this.krg = krg;
		this.krb = krb;
		this.krn = krn;
	}

	@Override
	public RayIntersection findClosestRayIntersection(Ray arg0) {
		class SphereRayIntersection extends RayIntersection {

			private double kdr;
			private double kdg;
			private double kdb;
			private double krr;
			private double krg;
			private double krb;
			private double krn;

			public SphereRayIntersection(Point3D point, double distance,
					boolean outer) {
				super(point, distance, outer);
				kdr = Sphere.this.kdr;
				kdg = Sphere.this.kdg;
				kdb = Sphere.this.kdb;
				krr = Sphere.this.krr;
				krg = Sphere.this.krg;
				krb = Sphere.this.krb;
				krn = Sphere.this.krn;
			}

			@Override
			public double getKdr() {
				return kdr;
			}

			@Override
			public double getKdg() {
				return kdg;
			}

			@Override
			public double getKdb() {
				return kdb;
			}

			@Override
			public double getKrr() {
				return krr;
			}

			@Override
			public double getKrg() {
				return krg;
			}

			@Override
			public double getKrb() {
				return krb;
			}

			@Override
			public double getKrn() {
				return krn;
			}

			@Override
			public Point3D getNormal() {
				return new Point3D(0, 1, 0);
			}

		}
		
		// using equation from
		// http://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
		// o - c (origin of the line - center of the sphere)
		Point3D oMinC = arg0.start.sub(center);
		double eqArg1 = -arg0.direction.scalarProduct(oMinC);
		// root arguments
		double rootArg1sqrt = arg0.direction.scalarProduct(oMinC);
		double rootArg1 = rootArg1sqrt * rootArg1sqrt;
		double rootArg2sqrt = oMinC.norm();
		double rootArg2 = -rootArg2sqrt * rootArg2sqrt;
		double rootArg3 = radius * radius;

		double underRoot = rootArg1 + rootArg2 + rootArg3;
		double eqArg2 = Math.sqrt(underRoot);

		double sol1 = eqArg1 - eqArg2;
		double sol2 = eqArg1 + eqArg2;

		if (sol1 >= 0) {
			return new SphereRayIntersection(arg0.start.add(arg0.direction
					.scalarMultiply(sol1)), sol1, true);
		} else if (sol2 >= 0) {
			return new SphereRayIntersection(arg0.start.add(arg0.direction
					.scalarMultiply(sol2)), sol2, false);
		} else {
			return null;
		}
	}
}
