package hr.fer.zemris.java.fractals.complex;


public final class ComplexRootedPolynomial {
	
	private Complex[] roots;

	// ...
	// constructor
	public ComplexRootedPolynomial(Complex... roots) {
		if (roots.length == 0) {
			throw new IllegalArgumentException();
		}
		this.roots = roots;
	}

	// computes polynomial value at given point z
	public Complex apply(Complex z) {
		Complex result = new Complex(1, 0);
		for (Complex complex : roots) {
			result = result.multiply(z.sub(complex));
		}
		
		return result;
	}

	// converts this representation to ComplexPolynomial type
	public ComplexPolynomial toComplexPolynom() {
		ComplexPolynomial sol = new ComplexPolynomial(Complex.ONE);
		for (Complex root : roots) {
			sol = sol.multiply(new ComplexPolynomial(Complex.ONE, root.negate()));
		}
		return sol;
	}

	@Override
	public String toString() {
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.append("f(z) = ");
		for (Complex complex : roots) {
			String rootAsString = complex.negate().toString();
			if (!rootAsString.startsWith("-")) {
				stringBuilder.append("+");
			}
			stringBuilder.append(String.format("(z %s)", complex.toString()));
		}
		
		return stringBuilder.toString();
	}

	// finds index of closest root for given complex number z that is within
	// treshold
	// if there is no such root, returns -1
	public int indexOfClosestRootFor(Complex z, double treshold) {
		double closestTreshold = treshold;
		int index = -1;
		for (int i = 0; i < roots.length; i++) {
			double currentTreshold = roots[i].sub(z).module();
			if(currentTreshold < closestTreshold) {
				closestTreshold = currentTreshold;
				index = i;
			}
		}
		
		return index + 1;
	}

}
