package hr.fer.zemris.java.fractals.complex;

import java.text.DecimalFormat;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class Complex {

	public static final Complex ZERO = new Complex(0, 0);
	public static final Complex ONE = new Complex(1, 0);
	public static final Complex ONE_NEG = new Complex(-1, 0);
	public static final Complex IM = new Complex(0, 1);
	public static final Complex IM_NEG = new Complex(0, -1);
	private static final double THETA = 1e-9;
	
	private double re;
	private double im;

	public Complex(double re, double im) {
		this.re = re;
		this.im = im;
	}

	// returns module of complex number
	public double module() {
		return Math.sqrt(im*im + re*re);
	}

	// returns this*c
	public Complex multiply(Complex c) {
		double re = this.re * c.re - this.im * c.im;
		double im = this.re * c.im + this.im * c.re;
		return new Complex(re, im);
	}

	// returns this/c
	public Complex divide(Complex c) {
		double denominator = c.im * c.im + c.re * c.re;
		if (denominator == 0) {
			throw new ArithmeticException("Division by zero.");
		}
		double re = this.re * c.re + this.im * c.im;
		re /= denominator;
		double im = this.im * c.re - this.re * c.im;
		im /= denominator;
		
		return new Complex(re, im);
	}

	// returns this+c
	public Complex add(Complex c) {
		return new Complex(this.re + c.re, this.im + c.im);
	}

	// returns this-c
	public Complex sub(Complex c) {
		return new Complex(this.re - c.re, this.im - c.im);
	}

	// returns -this
	public Complex negate() {
		return new Complex(-re, -im);
	}

	@Override
	public String toString() {
		double precision = 1e-6;
		boolean reZero = (Math.abs(re) < precision);
		boolean imZero = (Math.abs(im) < precision);
		if (reZero && imZero) {
			return "0";
		}
		
		StringBuilder stringBuilder = new StringBuilder();
		DecimalFormat firstRealFormatter = new DecimalFormat(
				"#.####;-#.####");
		DecimalFormat firstImaginaryFormatter = new DecimalFormat(
				"i#.####;-i#.####");
		DecimalFormat imaginaryFormatter = new DecimalFormat(
				" + i#.####; - i#.####");
		
		if (!reZero) {
			stringBuilder.append(firstRealFormatter.format(re));
		}
		if (!imZero) {
			if (reZero) {
				stringBuilder.append(firstImaginaryFormatter.format(im));
			} else {
				stringBuilder.append(imaginaryFormatter.format(im));
			}
		}
		
		return stringBuilder.toString();
	}
	
	public double getImaginary() {
		return im;
	}
	
	public double getReal() {
		return re;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof Complex)) {
			return false;
		}
		Complex comp = (Complex)obj;
		if (Math.abs(comp.re - this.re) < THETA && Math.abs(comp.im - this.im) < THETA) {
			return true;
		} else {
			return false;
		}
	}
	
	public static Complex parseComplex(String s) {
		
		if (s.trim().isEmpty()) {
			throw new IllegalArgumentException("Empty string given.");
		}
		
		/**
		 * real part of the complex number followed by spaces:
		 * ^([+\-]?\s*?(\d+\.?\d+|\d+))?\s*
		 * imaginary part of the complex number:
		 * ($|((^[+\-]?|[+\-])\s*?(\d+\.?\d+i|\d+i))?)$
		 */
		final Pattern complexPattern = Pattern
				.compile("^([+\\-]?\\s*?(\\d+\\.?\\d+|\\d+))?\\s*($|((^[+\\-]?|[+\\-])\\s*?(i\\d+\\.?\\d+|i\\d*))?)$");
		Matcher matcher = complexPattern.matcher(s.trim());

		double real, imaginary;
		if (matcher.matches()) {
			try {
				real = Double.parseDouble(matcher.group(1).replaceAll(
						"[\\t\\r\\n ]", ""));
			} catch (Exception noRealPart) {
				real = 0;
			}
			try {
				if (matcher.group(6).equals("i")) {
					imaginary = Double.parseDouble(matcher.group(3)
							.replaceAll("[\\t\\r\\n ]", "").replace("i", "1"));
				} else {
					imaginary = Double.parseDouble(matcher.group(3)
							.replaceAll("[\\t\\r\\n ]", "").replace("i", ""));					
				}
			} catch (Exception noImaginaryPart) {
				imaginary = 0;
			}
		} else {
			throw new NumberFormatException(
					"Given string is not a standard complex number");
		}

		return new Complex(real, imaginary);
	}

}
