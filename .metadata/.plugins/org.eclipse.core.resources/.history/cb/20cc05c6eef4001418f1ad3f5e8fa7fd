package hr.fer.zemris.java.raytracer;

import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;

import hr.fer.zemris.java.raytracer.model.GraphicalObject;
import hr.fer.zemris.java.raytracer.model.IRayTracerProducer;
import hr.fer.zemris.java.raytracer.model.IRayTracerResultObserver;
import hr.fer.zemris.java.raytracer.model.LightSource;
import hr.fer.zemris.java.raytracer.model.Point3D;
import hr.fer.zemris.java.raytracer.model.Ray;
import hr.fer.zemris.java.raytracer.model.RayIntersection;
import hr.fer.zemris.java.raytracer.model.Scene;
import hr.fer.zemris.java.raytracer.viewer.RayTracerViewer;

public class RayCasterParallel {
	public static void main(String[] args) {
		RayTracerViewer.show(getIRayTracerProducer(), new Point3D(10, 0, 0),
				new Point3D(0, 0, 0), new Point3D(0, 0, 10), 20, 20);
	}

	private static IRayTracerProducer getIRayTracerProducer() {
		return new IRayTracerProducer() {

			ForkJoinPool pool = new ForkJoinPool();

			@Override
			public void produce(Point3D eye, Point3D view, Point3D viewUp,
					double horizontal, double vertical, int width, int height,
					long requestNo, IRayTracerResultObserver observer) {

				System.out.println("Započinjem izračune...");
				short[] red = new short[width * height];
				short[] green = new short[width * height];
				short[] blue = new short[width * height];

				Point3D og = view.sub(eye).normalize();
				viewUp.modifyNormalize();

				Point3D yAxis = viewUp.sub(
						og.scalarMultiply(og.scalarProduct(viewUp)))
						.normalize();
				Point3D xAxis = og.vectorProduct(yAxis).normalize();

				Point3D screenCorner = view.sub(
						xAxis.scalarMultiply(horizontal / 2)).add(
						yAxis.scalarMultiply(vertical / 2));

				Scene scene = RayTracerViewer.createPredefinedScene();

				short[] rgb = new short[3];
				int offset = 0;

				class ColorCalculator extends RecursiveAction {

					private int xMin;
					private int xMax;
					private int yMin;
					private int yMax;
					private int offset;

					public ColorCalculator(int xMin, int xMax, int yMin,
							int yMax) {
						super();
						this.xMin = xMin;
						this.xMax = xMax;
						this.yMin = yMin;
						this.yMax = yMax;
						offset = yMin*width + xMin;
					}

					@Override
					protected void compute() {
						// TODO Auto-generated method stub

					}

					private void calc() {
						for (int y = 0; y < height; y++) {
							for (int x = 0; x < width; x++) {

								Point3D screenPoint = screenCorner.add(
										xAxis.scalarMultiply(horizontal * x
												/ (double) (width - 1))).sub(
										yAxis.scalarMultiply(vertical * y
												/ (double) (height - 1)));
								Ray ray = Ray.fromPoints(eye, screenPoint);

								tracer(scene, ray, rgb);

								red[offset] = rgb[0] > 255 ? 255 : rgb[0];
								green[offset] = rgb[1] > 255 ? 255 : rgb[1];
								blue[offset] = rgb[2] > 255 ? 255 : rgb[2];

								offset++;
							}
						}
					}

				}

				System.out.println("Izračuni gotovi...");
				observer.acceptResult(red, green, blue, requestNo);
				System.out.println("Dojava gotova...");
			}

			private void calcDataParallel(int offset, int length,
					double horizontal, double vertical, int height, int width,
					Point3D screenCorner, Point3D xAxis, Point3D yAxis,
					Point3D eye, Scene scene, short[] rgb) {

				for (int y = 0; y < height; y++) {
					for (int x = 0; x < width; x++) {

						Point3D screenPoint = screenCorner.add(
								xAxis.scalarMultiply(horizontal * x
										/ (double) (width - 1))).sub(
								yAxis.scalarMultiply(vertical * y
										/ (double) (height - 1)));
						Ray ray = Ray.fromPoints(eye, screenPoint);

						tracer(scene, ray, rgb);

						red[offset] = rgb[0] > 255 ? 255 : rgb[0];
						green[offset] = rgb[1] > 255 ? 255 : rgb[1];
						blue[offset] = rgb[2] > 255 ? 255 : rgb[2];

						offset++;
					}
				}
			}
		};
	}

	private static void tracer(Scene scene, Ray ray, final short[] rgb) {
		RayIntersection intersection = closestIntersectionInScene(scene, ray);
		System.arraycopy(determineColorFor(intersection, scene, ray), 0, rgb,
				0, 3);
	}

	private static short[] determineColorFor(RayIntersection intersection,
			Scene scene, Ray eyeRay) {

		if (intersection == null) {
			return new short[] { 0, 0, 0 };
		}

		short[] rgb = { 15, 15, 15 };
		for (LightSource light : scene.getLights()) {

			Ray lightRay = Ray.fromPoints(light.getPoint(),
					intersection.getPoint());
			RayIntersection lightIntersection = closestIntersectionInScene(
					scene, lightRay);

			if (lightIntersection != null
					&& lightIntersection.getPoint().sub(light.getPoint())
							.norm() + 1e-3 < intersection.getPoint()
							.sub(light.getPoint()).norm()) {
				continue;
			}

			int r = light.getR();
			int g = light.getG();
			int b = light.getB();

			Point3D toLight = lightRay.direction.negate();
			Point3D normal = intersection.getNormal();

			double cosFi = Math.max(toLight.scalarProduct(normal), 0);

			Point3D reflected = normal.scalarMultiply(
					toLight.scalarProduct(normal) * 2).modifySub(toLight);
			double cosAlpha = Math.max(
					reflected.scalarProduct(eyeRay.direction.negate()), 0);
			double cosNAlpha = (cosAlpha != 0) ? Math.pow(cosAlpha,
					intersection.getKrn()) : 0;

			rgb[0] += (short) ((intersection.getKdr() * cosFi + intersection
					.getKrr() * cosNAlpha) * r);
			rgb[1] += (short) ((intersection.getKdg() * cosFi + intersection
					.getKrg() * cosNAlpha) * g);
			rgb[2] += (short) ((intersection.getKdb() * cosFi + intersection
					.getKrb() * cosNAlpha) * b);
		}
		return rgb;
	}

	private static RayIntersection closestIntersectionInScene(Scene scene,
			Ray ray) {
		RayIntersection intersection = null;
		for (GraphicalObject object : scene.getObjects()) {

			RayIntersection objectIntersection = object
					.findClosestRayIntersection(ray);

			if (objectIntersection != null
					&& (intersection == null || objectIntersection
							.getDistance() < intersection.getDistance())) {
				intersection = objectIntersection;
			}
		}
		return intersection;
	}
}
