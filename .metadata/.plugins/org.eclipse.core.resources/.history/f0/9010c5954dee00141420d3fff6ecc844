package hr.fer.zemris.linearna;

import java.util.Arrays;

public class Matrix extends AbstractMatrix {

	protected double[][] elements;
	protected int rows;
	protected int cols;

	public Matrix(int rows, int cols) {
		this.rows = rows;
		this.cols = cols;
		this.elements = new double[rows][cols];
	}

	public Matrix(int rows, int cols, double[][] elements, boolean useGiven) {
		this(rows, cols);
		if (useGiven) {
			this.elements = elements;

		} else {
			for (int i = 0; i < elements.length; i++) {
				System.arraycopy(elements[i], 0, this.elements[i], 0, cols);
			}
		}
	}

	@Override
	public int getRowsCount() {
		return rows;
	}

	@Override
	public int getColsCount() {
		return cols;
	}

	@Override
	public double get(int row, int col) {
		validateCell(row, col);
		return elements[row][col];
	}

	@Override
	public IMatrix set(int row, int col, double value) {
		validateCell(row, col);
		elements[row][col] = value;
		return this;
	}

	@Override
	public IMatrix copy() {
		return new Matrix(rows, cols, elements, false);
	}

	@Override
	public IMatrix newInstance(int rows, int cols) {
		double[][] matrixArray =  new double[rows][cols];
		for (double[] ds : matrixArray) {
			Arrays.fill(ds, 0);
		}
		
		return new Matrix(rows, cols, matrixArray, true);
	}

	public static Matrix parseSimple(String s) {
		return null;
	}

	@Override
	public double[][] toArray() {
		double[][] copy = new double[rows][cols]; 
		for (int i = 0; i < elements.length; i++) {
			System.arraycopy(elements[i], 0, copy[i], 0, cols);
		}
		
		return copy;
	}

	private void validateCell(int row, int col) {
		if ((row < 0 || row >= rows) || (col < 0 || col >= cols)) {
			throw new IndexOutOfBoundsException(String.format(
					"Invalid row/collumn. Matrix has dimensions %dx%d", rows,
					cols));
		}
	}

}
